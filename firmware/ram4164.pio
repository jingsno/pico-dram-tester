;
; 4164 (and 4132 half-qualified chips) Test Program
;

; Pin Assignments
; SP0  = A0
; SP1  = A1
; SP2  = A2
; SP3  = A3
; SP4  = A4
; SP5  = A5
; SP6  = A6
; SP7  = A7
; SP8  = nc
; SP9  = D
; SP10 = WE#
; SP11 = RAS#
; SP12 = CAS#
; SP13 = nc
; SP14 = nc
; SP15 = nc
; SP16 = Q

; Timing values (nameplate, tRAC): 100ns, 120ns, 150ns, 200ns, 300ns

; set pins: CAS, RAS, WR.
.pio_version 0 // only requires PIO version 0
.program ram4164
; Note: We need to update the address lines and the RAS# at the same time.
    jmp begin
full_transfer:        ; (delay val at end of instr)
    nop [1]             ; [0] ES44
    nop [2]          ; 264.0 [26] tRC = 260.7ns
    out pins, 8       ; 3.3    Load row address
    set pins, 0b101   ; 6.6    Lower RAS#
    nop [3]           ; 26.4   [5] tRCD (RAS to CAS) = 26.4ns
cas_only_transfer:
    out pins, 10      ; 29.7     Load col address + write data
    jmp !x skip_wr    ; 33
    set pins, 0b000   ; 36.3     Lower CAS#, WR#
    jmp skip_wr2      ; 39.6
skip_wr:
    set pins, 0b001   ; 36.3     Lower CAS#
    nop               ; 39.6
skip_wr2:
    mov OSR, NULL     ; 42.9     Clear OSR  ES 8cyc+[3]=2=10
    nop [4]           ; 56.1     [3] ES 10+[4]=14
    set pins, 0b001   ; 59.4     Raise WR#  tWCH = 26.4ns. ES1+14=15
    out pins, 10      ; 62.7     Clear addr+data. tCAH, tDH = 29.7ns. ES1+15=16
    nop [5]          ; 108.9    [13] total = tRSH, tRSH ES 16+[5]=23
    in pins, 1        ; 112.2    Get bit tCAC = 75.9ns ES 24
    set pins, 0b101   ; 115.5    Raise CAS#. tCAS = 79.2ns ES 25
    push noblock      ; 118.8    ES 26
    nop [6]           ; 151.8    [9]   ES27+[6]=37
    jmp !y begin      ; 155.1 Raise RAS# only if we are doing a full transfer ES38
    jmp skip_ras      ; 158.4
begin:
    set pins, 0b111   ; 158.4 raise RAS#. tRAS=151.8ns  ES39.  = 3.3*37=122.1ns
skip_ras:
    pull block        ; 161.7 Wait for new data to arrive ES40
    out y, 1          ; 165.0 get first bit which tells us if this is fast page mode ES41
    out x, 1          ; 168.3 get second bit which tells us if we are in write mode. ES42
    jmp !y full_transfer ; 171.6 ES43
    out NULL, 8 [7]           ; 174.9 Throw out row address
    jmp cas_only_transfer ; 178.2 Fast page mode tCP=22*3.3=72.6ns


% c-sdk {
// Original delay numbers are 27, 5, 3, 13, 9
#define RAM4164_DELAYS 6
#define RAM4164_DELAY_FIELDS 8
static const uint8_t ram4164_delays[8][32] = {{0, 0,  20, 2,  2,  6,  5,  0},    // 100ns
                                              {0, 0,  25, 2,  4,  7,  8,  0},    // 120ns
                                              {0, 0,  25, 7,  4,  7,  8,  0},    // 120ns Changed index4 from 2 to 7, for tWCH=40ns
                                              {0, 0,  25, 2,  6, 10, 12,  0},    // 150ns
                                              {0, 0,  25, 7,  6, 10, 12,  0},    // 150ns Changed index4 from 2 to 7, for tWCH=40ns
                                              {0, 11, 20, 7, 13, 21,  4,  9},    // 200ns
                                              {0, 20, 20, 8, 19, 24,  9, 10},    // 250ns
                                              {0, 20, 20, 9, 22, 27, 19,  1} };  // 300ns

static inline void ram4164_program_init(PIO pio, uint sm, uint offset, uint pin) {
    uint count;

    // Set up 17 total pins
    for (count = 0; count < 17; count++) {
        pio_gpio_init(pio, pin + count);
        gpio_set_slew_rate(pin + count, GPIO_SLEW_RATE_FAST);
        gpio_set_drive_strength(pin + count, GPIO_DRIVE_STRENGTH_4MA);
    }
    pio_sm_set_consecutive_pindirs(pio, sm, pin, 13, true); // true=output
    pio_sm_set_consecutive_pindirs(pio, sm, pin + 16, 1, false); // input

    pio_sm_set_clkdiv(pio, sm, 1); // should just be the default.

    pio_sm_config c = ram4164_program_get_default_config(offset);
// A0, A1, A2, A3, A4, A5, A6, A7, nc, D, WR, RAS, CAS, nc, nc, nc, IN
    sm_config_set_out_pins(&c, pin, 10);
    sm_config_set_set_pins(&c, pin + 10, 3); // Max is 5.
    sm_config_set_in_pins(&c, pin + 16);

    // Shift right, Autopull off, 20 bits (1 + 1 + 8 + 10) at a time
    sm_config_set_out_shift(&c, true, false, 20);
    // Shift left, Autopull on, 1 bit
    sm_config_set_in_shift(&c, false, false, 1);

 //   hw_set_bits(&pio->input_sync_bypass, 1u << pin); to bypass synchronization on an input
    pio_sm_init(pio, sm, offset, &c);
    pio_sm_set_enabled(pio, sm, true);
}

// Routines for reading and writing memory through the FIFOs
int ram4164_ram_read(int addr)
{
    uint d;
    pio_sm_put(pio, sm, 0 |                     // Fast page mode flag
                        0 << 1 |                // Write flag
                        (addr & 0xff) << 2 |    // Row address
                        (addr & 0xff00) << 2|   // Column address
                        ((0 & 1) << 19));       // Data bit
    while (pio_sm_is_rx_fifo_empty(pio, sm)) {} // Wait for data to arrive
    d = pio_sm_get(pio, sm);                 // Return the data
    //gpio_put(GPIO_LED, d);
    return d;
}

int ram4164_half_col0_read(int addr)
{
    pio_sm_put(pio, sm, (addr & 0xff) << 2 |     // Row address
                       (addr & 0x7f00) << 2 );   // Column address
    while (pio_sm_is_rx_fifo_empty(pio, sm)) {} // Wait for data to arrive
    return pio_sm_get(pio, sm);
}

int ram4164_half_col1_read(int addr)
{
    pio_sm_put(pio, sm, (addr & 0xff) << 2 |     // Row address
                       ((addr & 0x7f00) | 0x8000) << 2 );  // Column address
    while (pio_sm_is_rx_fifo_empty(pio, sm)) {} // Wait for data to arrive
    return pio_sm_get(pio, sm);
}

int ram4164_half_row0_read(int addr)
{
    pio_sm_put(pio, sm, (addr & 0x7f) << 2 |     // Row address
                       ((addr << 1) & 0xff00) << 2 );  // Column address
    while (pio_sm_is_rx_fifo_empty(pio, sm)) {} // Wait for data to arrive
    return pio_sm_get(pio, sm);
}

int ram4164_half_row1_read(int addr)
{
    pio_sm_put(pio, sm, ((addr & 0x7f) | 0x80) << 2 |     // Row address
                       ((addr << 1) & 0xff00) << 2 );  // Column address
    while (pio_sm_is_rx_fifo_empty(pio, sm)) {} // Wait for data to arrive
    return pio_sm_get(pio, sm);
}

void ram4164_ram_write(int addr, int data)
{
    pio_sm_put(pio, sm, 0 |                     // Fast page mode flag
                        1 << 1 |                // Write flag
                        (addr & 0xff) << 2 |    // Row address
                        (addr & 0xff00) << 2|   // Column address
                        ((data & 1) << 19));    // Data bit
    while (pio_sm_is_rx_fifo_empty(pio, sm)) {} // Wait for dummy data
    pio_sm_get(pio, sm);                        // Discard the dummy data bit
}

void ram4164_half_col0_write(int addr, int data)
{
    // For 4164, addr = ccccccccrrrrrrrr.
    // For 4132, addr =  cccccccrrrrrrrr.
    // We need   addr = 0cccccccrrrrrrrr.
    pio_sm_put(pio, sm, 1 << 1 |                // Write flag
                        (addr & 0xff) << 2 |    // Row address
                        (addr & 0x7f00) << 2|   // Column address
                        ((data & 1) << 19));    // Data bit
    while (pio_sm_is_rx_fifo_empty(pio, sm)) {} // Wait for dummy data
    pio_sm_get(pio, sm);                        // Discard the dummy data bit
}

void ram4164_half_col1_write(int addr, int data)
{
    pio_sm_put(pio, sm, 1 << 1 |                // Write flag
                        (addr & 0xff) << 2 |    // Row address
                        ((addr & 0x7f00) | 0x8000) << 2|   // Column address
                        ((data & 1) << 19));    // Data bit
    while (pio_sm_is_rx_fifo_empty(pio, sm)) {} // Wait for dummy data
    pio_sm_get(pio, sm);                        // Discard the dummy data bit
}

void ram4164_half_row0_write(int addr, int data)
{
    // For 4164, addr = ccccccccrrrrrrrr.
    // For 4132, addr =  ccccccccrrrrrrr.
    // But we need      cccccccc0rrrrrrr.
    // addr = ccccccccrrrrrrr
    pio_sm_put(pio, sm, 1 << 1 |                // Write flag
                        (addr & 0x7f) << 2 |    // Row address
                        ((addr << 1) & 0xff00) << 2|   // Column address
                        ((data & 1) << 19));    // Data bit
    while (pio_sm_is_rx_fifo_empty(pio, sm)) {} // Wait for dummy data
    pio_sm_get(pio, sm);                        // Discard the dummy data bit
}

void ram4164_half_row1_write(int addr, int data)
{
    pio_sm_put(pio, sm, 1 << 1 |                // Write flag
                        ((addr & 0x7f) | 0x80) << 2 |    // Row address
                        ((addr << 1) & 0xff00) << 2|   // Column address
                        ((data & 1) << 19));    // Data bit
    while (pio_sm_is_rx_fifo_empty(pio, sm)) {} // Wait for dummy data
    pio_sm_get(pio, sm);                        // Discard the dummy data bit
}

// Routines to set up and tear down the PIO program (and the RAM test)
void ram4164_setup_pio(uint speed_grade, uint variant)
{
    uint pin = 5;
    set_current_pio_program(&ram4164_program);
    // Patches the program with the correct delay values
    pio_patch_delays(ram4164_delays[speed_grade], RAM4164_DELAY_FIELDS);
    bool rc = pio_claim_free_sm_and_add_program_for_gpio_range(get_current_pio_program(), &pio, &sm, &offset, pin, 17, true);
    ram4164_program_init(pio, sm, offset, pin);
    pio_sm_set_enabled(pio, sm, true);
}

void ram4164_half_setup_pio(uint speed_grade, uint variant);

void ram4164_teardown_pio()
{
    pio_sm_set_enabled(pio, sm, false);
    pio_remove_program_and_unclaim_sm(&ram4164_program, pio, sm, offset);
}

// This RAM chip configuration
static const mem_chip_t ram4164_chip = { .setup_pio = ram4164_setup_pio,
                                          .teardown_pio = ram4164_teardown_pio,
                                          .ram_read = ram4164_ram_read,
                                          .ram_write = ram4164_ram_write,
                                          .mem_size = 65536,
                                          .bits = 1,
                                          .variants = NULL,
                                          .speed_grades = RAM4164_DELAYS,
                                          .chip_name = "4164 (64Kx1)",
                                          .speed_names = {"100ns", "120ns", "120ns tWCH=40ns", "150ns", "150ns tWCH=40ns", "200ns", "250ns", "300ns"} };

// This RAM chip configuration
static const mem_chip_variants_t ram4164_half_chip_variants = {
                                          .num_variants = 4,
                                          .variant_names = {"TMS4532xxNL3 (low)", "TMS4532xxNL4 (high)",
                                                            "M3732L (low)", "M3732H (high)" } };
static mem_chip_t ram4164_half_chip = { .setup_pio = ram4164_half_setup_pio,
                                          .teardown_pio = ram4164_teardown_pio,
                                          .ram_read = ram4164_ram_read,
                                          .ram_write = ram4164_ram_write,
                                          .mem_size = 32768,
                                          .bits = 1,
                                          .variants = &ram4164_half_chip_variants,
                                          .speed_grades = RAM4164_DELAYS,
                                          .chip_name = "4132 (32Kx1 use 4164skt)",
                                          .speed_names = {"100ns", "120ns", "150ns", "200ns", "250ns", "300ns"} };

// Only used for half-qualified 4132 devices
void ram4164_half_setup_pio(uint speed_grade, uint variant)
{
    ram4164_setup_pio(speed_grade, 0);

    // Use appropriate read and write functions.
    switch (variant) {
        case 0:
            ram4164_half_chip.ram_read = ram4164_half_row0_read;
            ram4164_half_chip.ram_write = ram4164_half_row0_write;
            break;
        case 1:
           ram4164_half_chip.ram_read = ram4164_half_row1_read;
           ram4164_half_chip.ram_write = ram4164_half_row1_write;
           break;
        case 2:
           ram4164_half_chip.ram_read = ram4164_half_col0_read;
           ram4164_half_chip.ram_write = ram4164_half_col0_write;
           break;
        case 3:
           ram4164_half_chip.ram_read = ram4164_half_col1_read;
           ram4164_half_chip.ram_write = ram4164_half_col1_write;
           break;
        default:
            break;
    }
}



%}
